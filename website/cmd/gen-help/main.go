package main

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"

	"src.elv.sh/pkg/edit/highlight"
	"src.elv.sh/pkg/ui"
)

var highlighter = highlight.NewHighlighter(highlight.Config{})

func main() {
	if len(os.Args) > 1 {
		log.Fatal("Unexpected CLI arguments")
	}
	run(os.Stdin, os.Stdout)
}

func run(in io.Reader, out io.Writer) {
	fnHelpDocs := make(map[string]string)
	varHelpDocs := make(map[string]string)
	namespaces := make(map[string]struct{})
	var member struct{}

	fmt.Fprintln(out, "// Do Not Edit! This was generated by website/tools/gen-help.bin.")
	fmt.Fprintln(out, "package help")
	fmt.Fprintln(out, "")

	var itemName, itemType string
	builder := &strings.Builder{}
	bufr := bufio.NewReader(in)
	for {
		line, err := bufr.ReadString('\n')
		if err == io.EOF {
			break
		} else if err != nil {
			log.Fatal(err)
		}
		if strings.HasPrefix(line, "@@elvdoc:") {
			// We've detected the start of a new variable or function.
			if itemName != "" {
				namespaces[strings.SplitN(itemName, ":", 2)[0]] = member
				// Capture the previous item's documentation.
				documentation := strings.TrimSpace(builder.String())
				if itemType == "fn" {
					fnHelpDocs[itemName] = documentation
				} else {
					varHelpDocs[itemName] = documentation
				}
				builder.Reset()
			}

			if strings.HasPrefix(line, "@@elvdoc:fn:") {
				itemType = "fn"
			} else if strings.HasPrefix(line, "@@elvdoc:var:") {
				itemType = "var"
			} else {
				log.Fatal("unexpected item type: " + line)
			}
			prefixLen := len("@@elvdoc:") + len(itemType) + 1
			itemName = line[prefixLen : len(line)-1]
		} else {
			builder.WriteString(line)
		}
	}
	// Capture the last item's documentation.
	namespaces[strings.SplitN(itemName, ":", 2)[0]] = member
	if itemType == "fn" {
		fnHelpDocs[itemName] = builder.String()
	} else {
		varHelpDocs[itemName] = builder.String()
	}

	var sorted []string
	for ns := range namespaces {
		sorted = append(sorted, ns+":")
	}
	sort.Strings(sorted)
	addtlText := "\n\nThese are the known namespaces:\n"
	for i, ns := range sorted {
		if i%6 == 0 {
			addtlText += "\n    "
		}
		addtlText += fmt.Sprintf("%-12s ", ns)
	}
	fnHelpDocs["builtin:help"] += addtlText

	outputMap(out, "fn", fnHelpDocs)
	outputMap(out, "var", varHelpDocs)
}

func outputMap(out io.Writer, itemType string, m map[string]string) {
	fmt.Fprintf(out, "var %sHelpDocs = map[string]Text{\n", itemType)
	itemNames := make([]string, 0, len(m))
	for itemName := range m {
		itemNames = append(itemNames, itemName)
	}
	sort.Strings(itemNames)
	for _, itemName := range itemNames {
		fmt.Fprintf(out, "\t\"%s\": {\n", itemName)
		fmt.Fprintf(out, "\t\tdisplay: `%s`,\n", displayText(itemType, itemName, m[itemName]))
		fmt.Fprintf(out, "\t\tsearch:  `%s`,\n", searchText(itemType, itemName, m[itemName]))
		fmt.Fprintf(out, "\t},\n")
	}
	fmt.Fprintln(out, "}")
}

func itemDescription(itemType, itemName, usage string) string {
	if itemType == "fn" {
		highlighted, _ := highlighter.Get(itemName)
		return "Function " + highlighted.String() + ":"
	}
	highlighted, _ := highlighter.Get("$" + itemName)
	return "Variable " + highlighted.String() + ":"
}

func displayText(itemType, itemName, documentation string) string {
	return compress(itemDescription(itemType, itemName, "") + "\n\n" + documentation + "\n")
}

func searchText(itemType, itemName, documentation string) string {
	s := stripSGR(itemDescription(itemType, itemName, "") + "\n\n" + documentation + "\n")
	return compress(s)
}

func stripSGR(s string) string {
	builder := &strings.Builder{}
	for _, segment := range ui.ParseSGREscapedText(s) {
		s := strings.TrimSpace(segment.Text)
		s = strings.ReplaceAll(s, "\n", " ")
		s = strings.ReplaceAll(s, "  ", " ")
		builder.WriteString(s)
		builder.WriteRune(' ')
	}
	return builder.String()
}

func compress(s string) string {
	var b bytes.Buffer
	gz := gzip.NewWriter(&b)
	if _, err := gz.Write([]byte(s)); err != nil {
		panic(err)
	}
	if err := gz.Flush(); err != nil {
		panic(err)
	}
	if err := gz.Close(); err != nil {
		panic(err)
	}
	return base64.StdEncoding.EncodeToString(b.Bytes())
}
